// Code generated by counterfeiter. DO NOT EDIT.
package statemanagerfakes

import (
	"sync"

	"github.com/hyperledger/burrow/account"
	"github.com/hyperledger/burrow/binary"
	"github.com/hyperledger/fabric-chaincode-evm/statemanager"
)

type FakeStateWriter struct {
	GetAccountStub        func(address account.Address) (account.Account, error)
	getAccountMutex       sync.RWMutex
	getAccountArgsForCall []struct {
		address account.Address
	}
	getAccountReturns struct {
		result1 account.Account
		result2 error
	}
	getAccountReturnsOnCall map[int]struct {
		result1 account.Account
		result2 error
	}
	GetStorageStub        func(address account.Address, key binary.Word256) (binary.Word256, error)
	getStorageMutex       sync.RWMutex
	getStorageArgsForCall []struct {
		address account.Address
		key     binary.Word256
	}
	getStorageReturns struct {
		result1 binary.Word256
		result2 error
	}
	getStorageReturnsOnCall map[int]struct {
		result1 binary.Word256
		result2 error
	}
	UpdateAccountStub        func(updatedAccount account.Account) error
	updateAccountMutex       sync.RWMutex
	updateAccountArgsForCall []struct {
		updatedAccount account.Account
	}
	updateAccountReturns struct {
		result1 error
	}
	updateAccountReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveAccountStub        func(address account.Address) error
	removeAccountMutex       sync.RWMutex
	removeAccountArgsForCall []struct {
		address account.Address
	}
	removeAccountReturns struct {
		result1 error
	}
	removeAccountReturnsOnCall map[int]struct {
		result1 error
	}
	SetStorageStub        func(address account.Address, key, value binary.Word256) error
	setStorageMutex       sync.RWMutex
	setStorageArgsForCall []struct {
		address account.Address
		key     binary.Word256
		value   binary.Word256
	}
	setStorageReturns struct {
		result1 error
	}
	setStorageReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStateWriter) GetAccount(address account.Address) (account.Account, error) {
	fake.getAccountMutex.Lock()
	ret, specificReturn := fake.getAccountReturnsOnCall[len(fake.getAccountArgsForCall)]
	fake.getAccountArgsForCall = append(fake.getAccountArgsForCall, struct {
		address account.Address
	}{address})
	fake.recordInvocation("GetAccount", []interface{}{address})
	fake.getAccountMutex.Unlock()
	if fake.GetAccountStub != nil {
		return fake.GetAccountStub(address)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getAccountReturns.result1, fake.getAccountReturns.result2
}

func (fake *FakeStateWriter) GetAccountCallCount() int {
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	return len(fake.getAccountArgsForCall)
}

func (fake *FakeStateWriter) GetAccountArgsForCall(i int) account.Address {
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	return fake.getAccountArgsForCall[i].address
}

func (fake *FakeStateWriter) GetAccountReturns(result1 account.Account, result2 error) {
	fake.GetAccountStub = nil
	fake.getAccountReturns = struct {
		result1 account.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStateWriter) GetAccountReturnsOnCall(i int, result1 account.Account, result2 error) {
	fake.GetAccountStub = nil
	if fake.getAccountReturnsOnCall == nil {
		fake.getAccountReturnsOnCall = make(map[int]struct {
			result1 account.Account
			result2 error
		})
	}
	fake.getAccountReturnsOnCall[i] = struct {
		result1 account.Account
		result2 error
	}{result1, result2}
}

func (fake *FakeStateWriter) GetStorage(address account.Address, key binary.Word256) (binary.Word256, error) {
	fake.getStorageMutex.Lock()
	ret, specificReturn := fake.getStorageReturnsOnCall[len(fake.getStorageArgsForCall)]
	fake.getStorageArgsForCall = append(fake.getStorageArgsForCall, struct {
		address account.Address
		key     binary.Word256
	}{address, key})
	fake.recordInvocation("GetStorage", []interface{}{address, key})
	fake.getStorageMutex.Unlock()
	if fake.GetStorageStub != nil {
		return fake.GetStorageStub(address, key)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.getStorageReturns.result1, fake.getStorageReturns.result2
}

func (fake *FakeStateWriter) GetStorageCallCount() int {
	fake.getStorageMutex.RLock()
	defer fake.getStorageMutex.RUnlock()
	return len(fake.getStorageArgsForCall)
}

func (fake *FakeStateWriter) GetStorageArgsForCall(i int) (account.Address, binary.Word256) {
	fake.getStorageMutex.RLock()
	defer fake.getStorageMutex.RUnlock()
	return fake.getStorageArgsForCall[i].address, fake.getStorageArgsForCall[i].key
}

func (fake *FakeStateWriter) GetStorageReturns(result1 binary.Word256, result2 error) {
	fake.GetStorageStub = nil
	fake.getStorageReturns = struct {
		result1 binary.Word256
		result2 error
	}{result1, result2}
}

func (fake *FakeStateWriter) GetStorageReturnsOnCall(i int, result1 binary.Word256, result2 error) {
	fake.GetStorageStub = nil
	if fake.getStorageReturnsOnCall == nil {
		fake.getStorageReturnsOnCall = make(map[int]struct {
			result1 binary.Word256
			result2 error
		})
	}
	fake.getStorageReturnsOnCall[i] = struct {
		result1 binary.Word256
		result2 error
	}{result1, result2}
}

func (fake *FakeStateWriter) UpdateAccount(updatedAccount account.Account) error {
	fake.updateAccountMutex.Lock()
	ret, specificReturn := fake.updateAccountReturnsOnCall[len(fake.updateAccountArgsForCall)]
	fake.updateAccountArgsForCall = append(fake.updateAccountArgsForCall, struct {
		updatedAccount account.Account
	}{updatedAccount})
	fake.recordInvocation("UpdateAccount", []interface{}{updatedAccount})
	fake.updateAccountMutex.Unlock()
	if fake.UpdateAccountStub != nil {
		return fake.UpdateAccountStub(updatedAccount)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateAccountReturns.result1
}

func (fake *FakeStateWriter) UpdateAccountCallCount() int {
	fake.updateAccountMutex.RLock()
	defer fake.updateAccountMutex.RUnlock()
	return len(fake.updateAccountArgsForCall)
}

func (fake *FakeStateWriter) UpdateAccountArgsForCall(i int) account.Account {
	fake.updateAccountMutex.RLock()
	defer fake.updateAccountMutex.RUnlock()
	return fake.updateAccountArgsForCall[i].updatedAccount
}

func (fake *FakeStateWriter) UpdateAccountReturns(result1 error) {
	fake.UpdateAccountStub = nil
	fake.updateAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateWriter) UpdateAccountReturnsOnCall(i int, result1 error) {
	fake.UpdateAccountStub = nil
	if fake.updateAccountReturnsOnCall == nil {
		fake.updateAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateWriter) RemoveAccount(address account.Address) error {
	fake.removeAccountMutex.Lock()
	ret, specificReturn := fake.removeAccountReturnsOnCall[len(fake.removeAccountArgsForCall)]
	fake.removeAccountArgsForCall = append(fake.removeAccountArgsForCall, struct {
		address account.Address
	}{address})
	fake.recordInvocation("RemoveAccount", []interface{}{address})
	fake.removeAccountMutex.Unlock()
	if fake.RemoveAccountStub != nil {
		return fake.RemoveAccountStub(address)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.removeAccountReturns.result1
}

func (fake *FakeStateWriter) RemoveAccountCallCount() int {
	fake.removeAccountMutex.RLock()
	defer fake.removeAccountMutex.RUnlock()
	return len(fake.removeAccountArgsForCall)
}

func (fake *FakeStateWriter) RemoveAccountArgsForCall(i int) account.Address {
	fake.removeAccountMutex.RLock()
	defer fake.removeAccountMutex.RUnlock()
	return fake.removeAccountArgsForCall[i].address
}

func (fake *FakeStateWriter) RemoveAccountReturns(result1 error) {
	fake.RemoveAccountStub = nil
	fake.removeAccountReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateWriter) RemoveAccountReturnsOnCall(i int, result1 error) {
	fake.RemoveAccountStub = nil
	if fake.removeAccountReturnsOnCall == nil {
		fake.removeAccountReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeAccountReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateWriter) SetStorage(address account.Address, key binary.Word256, value binary.Word256) error {
	fake.setStorageMutex.Lock()
	ret, specificReturn := fake.setStorageReturnsOnCall[len(fake.setStorageArgsForCall)]
	fake.setStorageArgsForCall = append(fake.setStorageArgsForCall, struct {
		address account.Address
		key     binary.Word256
		value   binary.Word256
	}{address, key, value})
	fake.recordInvocation("SetStorage", []interface{}{address, key, value})
	fake.setStorageMutex.Unlock()
	if fake.SetStorageStub != nil {
		return fake.SetStorageStub(address, key, value)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.setStorageReturns.result1
}

func (fake *FakeStateWriter) SetStorageCallCount() int {
	fake.setStorageMutex.RLock()
	defer fake.setStorageMutex.RUnlock()
	return len(fake.setStorageArgsForCall)
}

func (fake *FakeStateWriter) SetStorageArgsForCall(i int) (account.Address, binary.Word256, binary.Word256) {
	fake.setStorageMutex.RLock()
	defer fake.setStorageMutex.RUnlock()
	return fake.setStorageArgsForCall[i].address, fake.setStorageArgsForCall[i].key, fake.setStorageArgsForCall[i].value
}

func (fake *FakeStateWriter) SetStorageReturns(result1 error) {
	fake.SetStorageStub = nil
	fake.setStorageReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateWriter) SetStorageReturnsOnCall(i int, result1 error) {
	fake.SetStorageStub = nil
	if fake.setStorageReturnsOnCall == nil {
		fake.setStorageReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setStorageReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateWriter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.getAccountMutex.RLock()
	defer fake.getAccountMutex.RUnlock()
	fake.getStorageMutex.RLock()
	defer fake.getStorageMutex.RUnlock()
	fake.updateAccountMutex.RLock()
	defer fake.updateAccountMutex.RUnlock()
	fake.removeAccountMutex.RLock()
	defer fake.removeAccountMutex.RUnlock()
	fake.setStorageMutex.RLock()
	defer fake.setStorageMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStateWriter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ statemanager.StateWriter = new(FakeStateWriter)
